const glfw = require("glfw3.jb");
const gl = require("gl.jb");

var libm_so = ffi.open("libm.so.6");
const sin = libm_so.sym("sin", ffi.double, [ffi.double]);
const cos = libm_so.sym("cos", ffi.double, [ffi.double]);
const sqrt = libm_so.sym("sqrt", ffi.double, [ffi.double]);

if (glfw.Init() == 0) return -1;

var width = 640, height = 480;

var window = glfw.CreateWindow(width, height, "Hello World", null, null);
if (window) { } else {
  glfw.Terminate();
  return -1;
}

var view_rotx = 20.0, view_roty = 30.0, view_rotz = 0.0;
var angle = 0.0;

const M_PI = 3.1415926538;

function gear(inner_radius, outer_radius, width, teeth, tooth_depth) {
  const r0 = inner_radius;
  const r1 = outer_radius - tooth_depth / 2.0;
  const r2 = outer_radius + tooth_depth / 2.0;

  const da = 2.0 * M_PI / teeth / 4.0;

  gl.ShadeModel(gl.FLAT);

  gl.Normal3f(0.0, 0.0, 1.0);

  /* draw front face */
  gl.Begin(gl.QUAD_STRIP);
  for (var i = 0; i <= teeth; i++) {
    var angle = i * 2.0 * M_PI / teeth;
    gl.Vertex3f(r0 * cos(angle), r0 * sin(angle), width * 0.5);
    gl.Vertex3f(r1 * cos(angle), r1 * sin(angle), width * 0.5);
    if (i < teeth) {
      gl.Vertex3f(r0 * cos(angle), r0 * sin(angle), width * 0.5);
      gl.Vertex3f(r1 * cos(angle + 3 * da), r1 * sin(angle + 3 * da),
                width * 0.5);
    }
  }
  gl.End();

  /* draw front sides of teeth */
  gl.Begin(gl.QUADS);
  for (var i = 0; i < teeth; i++) {
    var angle = i * 2.0 * M_PI / teeth;

    gl.Vertex3f(r1 * cos(angle), r1 * sin(angle), width * 0.5);
    gl.Vertex3f(r2 * cos(angle + da), r2 * sin(angle + da), width * 0.5);
    gl.Vertex3f(r2 * cos(angle + 2 * da), r2 * sin(angle + 2 * da),
                width * 0.5);
    gl.Vertex3f(r1 * cos(angle + 3 * da), r1 * sin(angle + 3 * da),
                width * 0.5);
  }
  gl.End();

  gl.Normal3f(0.0, 0.0, -1.0);

  /* draw back face */
  gl.Begin(gl.QUAD_STRIP);
  for (var i = 0; i <= teeth; i++) {
    var angle = i * 2.0 * M_PI / teeth;
    gl.Vertex3f(r1 * cos(angle), r1 * sin(angle), -width * 0.5);
    gl.Vertex3f(r0 * cos(angle), r0 * sin(angle), -width * 0.5);
    if (i < teeth) {
      gl.Vertex3f(r1 * cos(angle + 3 * da), r1 * sin(angle + 3 * da),
                -width * 0.5);
      gl.Vertex3f(r0 * cos(angle), r0 * sin(angle), -width * 0.5);
    }
  }
  gl.End();

  /* draw back sides of teeth */
  gl.Begin(gl.QUADS);
  for (var i = 0; i < teeth; i++) {
    var angle = i * 2.0 * M_PI / teeth;

    gl.Vertex3f(r1 * cos(angle + 3 * da), r1 * sin(angle + 3 * da),
                -width * 0.5);
    gl.Vertex3f(r2 * cos(angle + 2 * da), r2 * sin(angle + 2 * da),
                -width * 0.5);
    gl.Vertex3f(r2 * cos(angle + da), r2 * sin(angle + da), -width * 0.5);
    gl.Vertex3f(r1 * cos(angle), r1 * sin(angle), -width * 0.5);
  }
  gl.End();

  /* draw outward faces of teeth */
  gl.Begin(gl.QUAD_STRIP);
  for (var i = 0; i < teeth; i++) {
    var angle = i * 2.0 * M_PI / teeth;

    gl.Vertex3f(r1 * cos(angle), r1 * sin(angle), width * 0.5);
    gl.Vertex3f(r1 * cos(angle), r1 * sin(angle), -width * 0.5);
    var u = r2 * cos(angle + da) - r1 * cos(angle);
    var v = r2 * sin(angle + da) - r1 * sin(angle);
    var len = sqrt(u * u + v * v);
    u /= len;
    v /= len;
    gl.Normal3f(v, -u, 0.0);
    gl.Vertex3f(r2 * cos(angle + da), r2 * sin(angle + da), width * 0.5);
    gl.Vertex3f(r2 * cos(angle + da), r2 * sin(angle + da), -width * 0.5);
    gl.Normal3f(cos(angle), sin(angle), 0.0);
    gl.Vertex3f(r2 * cos(angle + 2 * da), r2 * sin(angle + 2 * da),
                width * 0.5);
    gl.Vertex3f(r2 * cos(angle + 2 * da), r2 * sin(angle + 2 * da),
                -width * 0.5);
    u = r1 * cos(angle + 3 * da) - r2 * cos(angle + 2 * da);
    v = r1 * sin(angle + 3 * da) - r2 * sin(angle + 2 * da);
    gl.Normal3f(v, -u, 0.0);
    gl.Vertex3f(r1 * cos(angle + 3 * da), r1 * sin(angle + 3 * da),
                width * 0.5);
    gl.Vertex3f(r1 * cos(angle + 3 * da), r1 * sin(angle + 3 * da),
                -width * 0.5);
    gl.Normal3f(cos(angle), sin(angle), 0.0);
  }

  gl.Vertex3f(r1 * cos(0), r1 * sin(0), width * 0.5);
  gl.Vertex3f(r1 * cos(0), r1 * sin(0), -width * 0.5);

  gl.End();

  gl.ShadeModel(gl.SMOOTH);

  /* draw inside radius cylinder */
  gl.Begin(gl.QUAD_STRIP);
  for (var i = 0; i <= teeth; i++) {
    var angle = i * 2.0 * M_PI / teeth;
    gl.Normal3f(-cos(angle), -sin(angle), 0.0);
    gl.Vertex3f(r0 * cos(angle), r0 * sin(angle), -width * 0.5);
    gl.Vertex3f(r0 * cos(angle), r0 * sin(angle), width * 0.5);
  }
  gl.End();
}

function drawGL() {
  var h = (height * 1.0) / width;
  gl.MatrixMode(gl.PROJECTION);
  gl.LoadIdentity();
  gl.Frustum(-1.0, 1.0, -h, h, 5.0, 60.0);
  gl.MatrixMode(gl.MODELVIEW);
  gl.LoadIdentity();
  
  gl.Translatef(0.0, 0.0, -40.0);
  
  gl.ShadeModel(gl.SMOOTH);
  gl.ClearDepth(1);
  gl.DepthFunc(gl.LEQUAL);
  gl.Enable(gl.DEPTH_TEST);
  gl.Enable(gl.CULL_FACE);
  gl.Enable(gl.LIGHTING);
  gl.Enable(gl.COLOR_MATERIAL);
  gl.Enable(gl.LIGHT0);
  gl.ClearColor(0.2, 0.2, 0.2, 0);
  gl.Hint(gl.PERSPECTIVE_CORRECTION_HINT, gl.NICEST);
  
  gl.Clear(gl.COLOR_BUFFER_BIT + gl.DEPTH_BUFFER_BIT);
  gl.Color3f(1, 1, 1);
  
  gl.PushMatrix();
  gl.Rotatef(view_rotx, 1.0, 0.0, 0.0);
  gl.Rotatef(view_roty, 0.0, 1.0, 0.0);
  gl.Rotatef(view_rotz, 0.0, 0.0, 1.0);
  
  gl.PushMatrix();
  gl.Translatef(-3.0, -2.0, 0.0);
  gl.Rotatef(angle, 0.0, 0.0, 1.0);
  gl.Color3f(0.8, 0.1, 0.0);
  gear(1.0, 4.0, 1.0, 20, 0.7);
  gl.PopMatrix();

  gl.PushMatrix();
  gl.Translatef(3.1, -2.0, 0.0);
  gl.Rotatef(-2.0 * angle - 9.0, 0.0, 0.0, 1.0);
  gl.Color3f(0.0, 0.8, 0.2);
  gear(0.5, 2.0, 2.0, 10, 0.7);
  gl.PopMatrix();

  gl.PushMatrix();
  gl.Translatef(-3.1, 4.2, 0.0);
  gl.Rotatef(-2.0 * angle - 25.0, 0.0, 0.0, 1.0);
  gl.Color3f(0.2, 0.2, 1.0);
  gear(1.3, 2.0, 0.5, 10, 0.7);
  gl.PopMatrix();

  gl.PopMatrix();
}

glfw.MakeContextCurrent(window);
gl.Viewport(0, 0, width, height);
glfw.SwapInterval(1);

print("loop start");
for (var frame = 0; frame < 1000; frame++) {
// while (glfw.WindowShouldClose(window) == 0) {
  drawGL();
  angle += 2;
  // glfw.SwapBuffers(window);
  glfw.PollEvents();
}
print("loop end");

glfw.Terminate();
