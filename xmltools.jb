// swig -v -includeall -ignoremissing -module [name] -outcurrentdir -xml /usr/include/[header]
function print_xml(node, depth) {
  var spacing = "";
  for (var i = 0; i < depth; i++) {
    spacing = spacing + "  ";
  }
  if (node.nodeType == 1) {
    var attrs = "";
    var attr_names = keys(node.attr);
    for (var i = 0; i < attr_names.length; i++) {
      attrs = attrs + " " + attr_names[i]+"='"+node.attr[attr_names[i]]+"'";
    }
    print(spacing, "<", node.nodeName, attrs, ">");
    for (var i = 0; i < node.children.length; i++) {
      print_xml(node.children[i], depth + 1);
    }
    print(spacing, "</", node.nodeName, ">");
  }
}
xml.node["toStringBits"] = method(arr) {
  if (this.nodeType == 1) {
    arr.push("<");
    arr.push(this.nodeName);
    var attr_names = keys(this.attr);
    for (var i:int = 0; i < attr_names.length; i++) {
      arr.push(" ");
      arr.push(attr_names[i]);
      arr.push("='");
      arr.push(this.attr[attr_names[i]]);
      arr.push("'");
    }
    arr.push(">");
    for (var i:int = 0; i < this.children.length; i++) {
      this.children[i].toStringBits(arr);
    }
    arr.push("</");
    arr.push(this.nodeName);
    arr.push(">");
  }
};
xml.node["toString"] = method() {
  var bits = [];
  this.toStringBits(bits);
  return bits.join("");
};
var XmlResults = {
  array = [];
  length = 0;
  "[]" = method(i) { return this.array[i]; };
  combine = method(res2) {
    var array2 = [];
    for (var i = 0; i < this.array.length; i++) {
      array2.push(this.array[i]);
    }
    for (var i = 0; i < res2.array.length; i++) {
      array2.push(res2.array[i]);
    }
    return new XmlResults {
      array = array2;
      length = array2.length;
    };
  };
  filter = method(pred) {
    var res = [];
    for (var i = 0; i < this.array.length; i++) {
      var entry = this.array[i];
      if (pred(entry)) res.push(entry);
    }
    return new XmlResults {
      array = res;
      length = res.length;
    };
  };
  children = method(pred) {
    var res = [];
    for (var i = 0; i < this.array.length; i++) {
      var entry = this.array[i];
      for (var k = 0; k < entry.children.length; k++) {
        var child = entry.children[k];
        if (pred(child)) res.push(child);
      }
    }
    return new XmlResults {
      array = res;
      length = res.length;
    };
  };
  find = method(pred) {
    var res = new XmlResults;
    for (var i = 0; i < this.array.length; i++) {
      res = res.combine(this.array[i].find(pred));
    }
    return res;
  };
  on = method(key, fn) {
    assert(this.array.length > 0, "called on() on empty result set");
    for (var i = 0; i < this.array.length; i++) {
      this.array[i].on(key, fn);
    }
    return this;
  };
  trigger = method(key, ...) {
    for (var i = 0; i < this.array.length; i++) {
      this.array[i].trigger_(key, arguments);
    }
    return this;
  };
};
xml.node["find"] = method(pred) {
  if (pred instanceof string) return this.findByName(pred);
  var array = this.find_array(pred);
  return new XmlResults {
    array = array;
    length = array.length;
  };
};
xml.node["findByName"] = method(name) {
  // var array = this.find_array(function(node) { return node.nodeName == name; });
  var array = this.find_array_by_name(name);
  return new XmlResults {
    array = array;
    length = array.length;
  };
};
xml.node["append"] = method(arg) {
  if (arg instanceof string) {
    arg = xml.parse(arg);
  }
  var array_arg;
  if (arg instanceof array) array_arg = arg;
  else if (arg instanceof XmlResults) array_arg = arg.array;
  if (array_arg) {
    for (var i = 0; i < array_arg.length; i++) {
      this.children.push(array_arg[i]);
      array_arg[i].parent = this;
    }
  } else {
    this.children.push(arg);
    arg.parent = this;
  }
};
const EventHandlers = {
  fns = [];
  call = method(base, arguments) {
    for (var i = 0; i < this.fns.length; i++) {
      var obj = this.fns[i];
      if (!obj.fn.apply(obj.obj, arguments)) return false;
    }
    return true;
  };
};
// TODO figure out a better performing way to do this
xml.node["on"] = method(key, obj) {
  if (obj instanceof function) obj = { fn = obj; obj = this; };
  if (!("_handlers" in this)) this["_handlers"] = {};
  if (!("key" in this._handlers)) this._handlers[key] = new EventHandlers;
  this._handlers[key].fns.push(obj);
  if (this.parent) this.parent.on(key, obj);
};
xml.node["trigger_"] = method(key, arguments) {
  if ("_handlers" in this && key in this._handlers) {
    if (!this._handlers[key].call(this, arguments)) return false;
  }
  return true;
};
xml.node["trigger"] = method(key, ...) {
  this.trigger_(key, arguments);
};
