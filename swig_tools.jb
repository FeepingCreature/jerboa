const xmltools = require("xmltools.jb");
const getAttr = xmltools.getAttr;

var global_typemap = {};
function xml_type_to_ffi(type) {
  // print("  debug: ", type);
  if (type == "p.char") return ffi.char_pointer;
  if (type == "p.q(const).char") return ffi.char_pointer;
  if (type.startsWith("a(")) return null;
  if (type.startsWith("q(const).")) type = type.startsWith("q(const).");
  if (type.startsWith("p.")) return ffi.pointer;
  if (type.startsWith("v(")) return null;
  if (type.startsWith("enum ")) return ffi.int;
  if (type.startsWith("struct ")) return null;
  if (type == "char") return null;
  if (type == "iconv_t") return null;
  if (type == "int") return ffi.int;
  if (type == "size_t") return ffi.pointer;
  if (type == "void") return ffi.void;
  if (type == "float") return ffi.float;
  if (type == "short") return null;
  if (type == "double") return ffi.double;
  if (type == "signed char") return null;
  if (type == "unsigned int") return ffi.uint;
  if (type == "unsigned char") return null;
  if (type == "unsigned short") return null;
  if (type == "long") return ffi.long;
  if (type == "unsigned long") return ffi.ulong;
  if (type == "uint8_t") return ffi.uint8;
  if (type == "uint16_t") return ffi.uint16;
  if (type == "uint32_t") return ffi.uint32;
  if (type == "uint64_t") return ffi.uint64;
  if (type == "int8_t") return ffi.int8;
  if (type == "int16_t") return ffi.int16;
  if (type == "int32_t") return ffi.int32;
  if (type == "int64_t") return ffi.int64;
  if (type in global_typemap) {
    return xml_type_to_ffi(global_typemap[type]);
  }
  return null;
}

function loadLibraryWithPrefix(xml_file, lib_file, prefix) {
  var xmldata = xml.load(xml_file);
  print("select decls");
  var count = 0;
  var decls = xmldata.findByName("cdecl");
  print("done. ", decls.length, " from ", count);
  print("filter typedefs");
  var typedefs = decls.filter(function(node) {
    return getAttr(node, "kind") == "typedef";
  });
  print("done. ", typedefs.length);
  print("process typedefs");
  for (var i = 0; i < typedefs.length; i++) {
    var typedef = typedefs[i];
    var name = getAttr(typedef, "name");
    var prefix = "";
    if (getAttr(typedef, "decl").startsWith("p.")) prefix += "p.";
    print(name, " = ", prefix + getAttr(typedef, "type"));
    global_typemap[name] = prefix + getAttr(typedef, "type");
  }
  print("done.");
  
  var obj = {};
  var library = ffi.open(lib_file);
  print("select fn decls");
  var fndecls = decls.filter(function(node) {
    return getAttr(node, "kind") == "function";
  });
  print("done.");
  print("parse ", fndecls.length, " fn decls");
  for (var i = 0; i < fndecls.length; i++) {
    var decl = fndecls[i];
    print("? ", getAttr(decl, "name"));
    var ret_type;
    // print(getAttr(decl, "decl"), ", ", getAttr(decl, "type"), " # ", getAttr(decl, "decl").endsWith(".p."));
    if (getAttr(decl, "decl").endsWith(".p.")) ret_type = ffi.pointer; // why, ffi
    else ret_type = xml_type_to_ffi(getAttr(decl, "type"));
    if (ret_type) {
      var parms = decl.findByName("parm");
      var par_types = [];
      var good = true;
      for (var k = 0; k < parms.length; k++) {
        var parm = parms[k];
        var typestr = getAttr(parm, "type");
        var skip = 0;
        if (parms.length == 1) { if (typestr == "void") { skip = 1; } }
        if (skip == 0) {
          var type = xml_type_to_ffi(typestr);
          if (type) { } else {
            good = false;
            print("arg skip ", getAttr(decl, "name"), " due to ", typestr);
          }
          par_types.push(type);
        }
      }
      if (good) {
        var name = getAttr(decl, "name");
        var sym = library.sym(name, ret_type, par_types);
        if (sym) {
          // print("+ ", name);
          if (name.startsWith(prefix)) name = name.startsWith(prefix);
          obj[name] = sym;
        } else print("sym skip ", getAttr(decl, "name"));
      } else print("bad skip ", getAttr(decl, "name"));
    } else print("ret skip ", getAttr(decl, "name"));
  }
  print("done.");
  print("filter constants");
  var constants = xmldata.findByName("constant");
  print("done.");
  print("parse ", constants.length, " constants");
  for (var i = 0; i < constants.length; i++) {
    var constant = constants[i];
    var name = getAttr(constant, "name");
    var value = getAttr(constant, "value");
    value = int.parse(value);
    // print("+ '", name, "'");
    if (name.startsWith(prefix)) name = name.startsWith(prefix);
    obj[name] = value;
  }
  print("done.");
  // swig doesn't generate this properly for sdl
  /*
  print("filter enum items");
  var enumitems = xmldata.findByName("enumitem");
  print("done.");
  print("parse ", enumitems.length, " flags");
  for (var i = 0; i < enumitems.length; i++) {
    var enumitem = enumitems[i];
    var name = getAttr(enumitem, "name");
    var value = getAttr(enumitem, "value");
    value = int.parse(value);
    obj[name] = value;
  }
  print("done.");
  */
  freeze(obj);
  return obj;
}
function loadLibrary(xml_file, lib_file) {
  return loadLibraryWithPrefix(xml_file, lib_file, "");
}
