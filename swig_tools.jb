function print_xml(node, depth) {
  var spacing = "";
  for (var i = 0; i < depth; i++) {
    spacing = spacing + "  ";
  }
  if (node.nodeType == 1) {
    var attrs = "";
    var attr_names = keys(node.attr);
    for (var i = 0; i < attr_names.length; i++) {
      attrs = attrs + " " + attr_names[i]+"='"+node.attr[attr_names[i]]+"'";
    }
    print(spacing, "<", node.nodeName, attrs, ">");
    for (var i = 0; i < node.children.length; i++) {
      print_xml(node.children[i], depth + 1);
    }
    print(spacing, "</", node.nodeName, ">");
  }
}
// var i = 0; i /= i;
xml.node["toString"] = method() {
  if (this.nodeType == 1) {
    var res = "";
    var attrs = "";
    var attr_names = keys(this.attr);
    for (var i = 0; i < attr_names.length; i++) {
      attrs = attrs + " " + attr_names[i]+"='"+this.attr[attr_names[i]]+"'";
    }
    res = res + "<"+this.nodeName+attrs+">";
    for (var i = 0; i < this.children.length; i++) {
      var str = this.children[i].toString();
      if (str) res = res + str;
    }
    res = res + "</" + this.nodeName + ">";
    return res;
  }
  return null;
};
var XmlResults = {
  array: [],
  length: 0,
  "[]": method(i) { return this.array[i]; },
  combine: method(res2) {
    var array2 = [];
    for (var i = 0; i < this.array.length; i++) {
      array2.push(this.array[i]);
    }
    for (var i = 0; i < res2.array.length; i++) {
      array2.push(res2.array[i]);
    }
    return new XmlResults {
      array: array2,
      length: array2.length
    };
  },
  filter: method(pred) {
    var res = [];
    for (var i = 0; i < this.array.length; i++) {
      var entry = this.array[i];
      if (pred(entry)) res.push(entry);
    }
    return new XmlResults {
      array: res,
      length: res.length
    };
  },
  children: method(pred) {
    var res = [];
    for (var i = 0; i < this.array.length; i++) {
      var entry = this.array[i];
      for (var k = 0; k < entry.children.length; k++) {
        var child = entry.children[k];
        if (pred(child)) res.push(child);
      }
    }
    return new XmlResults {
      array: res,
      length: res.length
    };
  },
  find: method(pred) {
    var res = new XmlResults;
    for (var i = 0; i < this.array.length; i++) {
      res = res.combine(this.array[i].find(pred));
    }
    return res;
  },
};
xml.node["find"] = method(pred) {
  var array = this.find_array(pred);
  return new XmlResults {
    array: array,
    length: array.length
  };
};
xml.node["findByName"] = method(name) {
  // var array = this.find_array(function(node) { return node.nodeName == name; });
  var array = this.find_array_by_name(name);
  return new XmlResults {
    array: array,
    length: array.length
  };
};
function getAttr(node, name) {
  // <attributelist><attribute></attribute></attributelist>
  var firstSubNode = null;
  var i = 0;
  var children = node.children;
  while (children[i].nodeType != 1) {
    i++;
    if (i == children.length) { print("fail"); (1/0); }
  }
  var attrs = children[i].children;
  for (var i = 0; i < attrs.length; i++) {
    var attr = attrs[i];
    if (attr.nodeName == "attribute") {
      if (attr.attr["name"] == name) {
        return attr.attr["value"];
      }
    }
  }
  print("fail");
  (1/0);
}

var global_typemap = {};
function loadLibrary(xml_file, lib_file) {
  var xmldata = xml.load(xml_file);
  print("select decls");
  var count = 0;
  var decls = xmldata.findByName("cdecl");
  print("done. ", decls.length, " from ", count);
  print("filter typedefs");
  var typedefs = decls.filter(function(node) {
    return getAttr(node, "kind") == "typedef";
  });
  print("done. ", typedefs.length);
  print("process typedefs");
  for (var i = 0; i < typedefs.length; i++) {
    var typedef = typedefs[i];
    global_typemap[getAttr(typedef, "name")] = getAttr(typedef, "type");
  }
  print("done.");
  function xml_type_to_ffi(type) {
    // print("  debug: ", type);
    if (type.startsWith("a(")) return null;
    if (type.startsWith("q(const).")) type = type.startsWith("q(const).");
    if (type.startsWith("p.")) return ffi.pointer;
    if (type.startsWith("v(")) return null;
    if (type.startsWith("enum ")) return null;
    if (type.startsWith("struct ")) return null;
    if (type == "char") return null;
    if (type == "iconv_t") return null;
    if (type == "int") return ffi.sint;
    if (type == "size_t") return ffi.pointer;
    if (type == "void") return ffi.void;
    if (type == "float") return ffi.float;
    if (type == "short") return null;
    if (type == "double") return ffi.double;
    if (type == "signed char") return null;
    if (type == "unsigned int") return ffi.uint;
    if (type == "unsigned char") return null;
    if (type == "unsigned short") return null;
    if (type == "long") return null;
    if (type == "unsigned long") return null;
    if (type == "uint8_t") return ffi.uint8;
    if (type == "uint16_t") return ffi.uint16;
    if (type == "uint32_t") return ffi.uint32;
    if (type == "uint64_t") return ffi.uint64;
    if (type == "int8_t") return ffi.int8;
    if (type == "int16_t") return ffi.int16;
    if (type == "int32_t") return ffi.int32;
    if (type == "int64_t") return ffi.int64;
    return xml_type_to_ffi(global_typemap[type]);
  }
  
  var obj = {};
  var library = ffi.open(lib_file);
  print("select fn decls");
  var fndecls = decls.filter(function(node) {
    return getAttr(node, "kind") == "function";
  });
  print("done.");
  print("parse ", fndecls.length, " fn decls");
  for (var i = 0; i < fndecls.length; i++) {
    var decl = fndecls[i];
    // print("? ", getAttr(decl, "name"));
    var ret_type;
    // print(getAttr(decl, "decl"), ", ", getAttr(decl, "type"), " # ", getAttr(decl, "decl").endsWith(".p."));
    if (getAttr(decl, "decl").endsWith(".p.")) ret_type = ffi.pointer; // why, ffi
    else ret_type = xml_type_to_ffi(getAttr(decl, "type"));
    if (ret_type) {
      var parms = decl.findByName("parm");
      var par_types = [];
      var good = true;
      for (var k = 0; k < parms.length; k++) {
        var parm = parms[k];
        var typestr = getAttr(parm, "type");
        var skip = 0;
        if (parms.length == 1) { if (typestr == "void") { skip = 1; } }
        if (skip == 0) {
          var type = xml_type_to_ffi(typestr);
          if (type) { } else {
            good = false;
            // print("arg skip ", getAttr(decl, "name"));
          }
          par_types.push(type);
        }
      }
      if (good) {
        var name = getAttr(decl, "name");
        var sym = library.sym(name, ret_type, par_types);
        if (sym) {
          // print("+ ", name);
          obj[name] = sym;
        } // else print("sym skip ", getAttr(decl, "name"));
      } // else print("bad skip ", getAttr(decl, "name"));
    } // else print("ret skip ", getAttr(decl, "name"));
  }
  print("done.");
  print("filter constants");
  var constants = xmldata.findByName("constant");
  print("done.");
  print("parse ", constants.length, " constants");
  for (var i = 0; i < constants.length; i++) {
    var constant = constants[i];
    var name = getAttr(constant, "name");
    var value = getAttr(constant, "value");
    value = int.parse(value);
    // print("+ '", name, "'");
    obj[name] = value;
  }
  print("done.");
  // swig doesn't generate this properly for sdl
  /*
  print("filter enum items");
  var enumitems = xmldata.findByName("enumitem");
  print("done.");
  print("parse ", enumitems.length, " flags");
  for (var i = 0; i < enumitems.length; i++) {
    var enumitem = enumitems[i];
    var name = getAttr(enumitem, "name");
    var value = getAttr(enumitem, "value");
    value = int.parse(value);
    obj[name] = value;
  }
  print("done.");
  */
  return obj;
}
