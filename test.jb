var libc_so = ffi.open("libc.so.6");
var puts = libc_so.sym("puts", ffi.sint, [ffi.char_pointer]);
var malloc = libc_so.sym("malloc", ffi.pointer, [ffi.sint]);
puts("Hello World from libffi!");

function print_xml(node, depth) {
  var spacing = "";
  var i = 0;
  while (i < depth) {
    spacing = spacing + "  ";
    i = i + 1;
  }
  if (node.nodeType == 1) {
    var attrs = "";
    var attr_names = keys(node.attr);
    i = 0;
    while (i < attr_names.length) {
      attrs = attrs + " " + attr_names[i]+"='"+node.attr[attr_names[i]]+"'";
      i = i + 1;
    }
    print(spacing, "<", node.nodeName, attrs, ">");
    i = 0;
    while (i < node.children.length) {
      print_xml(node.children[i], depth + 1);
      i = i + 1;
    }
    print(spacing, "</", node.nodeName, ">");
  }
}
xml.node["toString"] = method() {
  if (this.nodeType == 1) {
    var res = "";
    var attrs = "";
    var attr_names = keys(this.attr);
    var i = 0;
    while (i < attr_names.length) {
      attrs = attrs + " " + attr_names[i]+"='"+this.attr[attr_names[i]]+"'";
      i = i + 1;
    }
    res = res + "<"+this.nodeName+attrs+">";
    i = 0;
    while (i < this.children.length) {
      var str = this.children[i].toString();
      if (str) res = res + str;
      i = i + 1;
    }
    res = res + "</" + this.nodeName + ">";
    return res;
  }
  return null;
};
var XmlResults = {
  array: [],
  length: 0,
  "[]": method(i) { return this.array[i]; },
  combine: method(res2) {
    var array2 = [];
    var i = 0;
    while (i < this.array.length) {
      array2.push(this.array[i]);
      i = i + 1;
    }
    i = 0;
    while (i < res2.array.length) {
      array2.push(res2.array[i]);
      i = i + 1;
    }
    return new XmlResults {
      array: array2,
      length: array2.length
    };
  },
  filter: method(pred) {
    var res = [];
    var i = 0;
    while (i < this.array.length) {
      var entry = this.array[i];
      if (pred(entry)) res.push(entry);
      i = i + 1;
    }
    return new XmlResults {
      array: res,
      length: res.length
    };
  },
  children: method(pred) {
    var res = [];
    var i = 0;
    while (i < this.array.length) {
      var entry = this.array[i];
      var k = 0;
      while (k < entry.children.length) {
        var child = entry.children[k];
        if (pred(child)) res.push(child);
        k = k + 1;
      }
      i = i + 1;
    }
    return new XmlResults {
      array: res,
      length: res.length
    };
  },
  find: method(pred) {
    var res = new XmlResults;
    var i = 0;
    while (i < this.array.length) {
      res = res.combine(this.array[i].find(pred));
      i = i + 1;
    }
    return res;
  },
};
xml.node["find"] = method(pred) {
  var array = this.find_array(pred);
  return new XmlResults {
    array: array,
    length: array.length
  };
};
xml.node["findByName"] = method(name) {
  // var array = this.find_array(function(node) { return node.nodeName == name; });
  var array = this.find_array_by_name(name);
  return new XmlResults {
    array: array,
    length: array.length
  };
};
function getAttr(node, name) {
  // <attributelist><attribute></attribute></attributelist>
  var firstSubNode = null;
  var i = 0;
  var children = node.children;
  while (children[i].nodeType != 1) {
    i = i + 1;
    if (i == children.length) { print("fail"); (1/0); }
  }
  var attrs = children[i].children;
  i = 0;
  while (i < attrs.length) {
    var attr = attrs[i];
    if (attr.nodeName == "attribute") {
      if (attr.attr["name"] == name) {
        return attr.attr["value"];
      }
    }
    i = i + 1;
  }
  print("fail");
  (1/0);
}

var global_typemap = {};
function loadLibrary(xml_file, lib_file) {
  var xmldata = xml.load(xml_file);
  print("select decls");
  var count = 0;
  var decls = xmldata.findByName("cdecl");
  print("done. ", decls.length, " from ", count);
  print("filter typedefs");
  var typedefs = decls.filter(function(node) {
    return getAttr(node, "kind") == "typedef";
  });
  print("done. ", typedefs.length);
  print("process typedefs");
  var i = 0;
  while (i < typedefs.length) {
    var typedef = typedefs[i];
    global_typemap[getAttr(typedef, "name")] = getAttr(typedef, "type");
    i = i + 1;
  }
  print("done.");
  function xml_type_to_ffi(type) {
    // print("  debug: ", type);
    if (type.startsWith("a(")) return null;
    if (type.startsWith("q(const).")) type = type.startsWith("q(const).");
    if (type.startsWith("p.")) return ffi.pointer;
    if (type.startsWith("v(")) return null;
    if (type.startsWith("enum ")) return null;
    if (type.startsWith("struct ")) return null;
    if (type == "char") return null;
    if (type == "iconv_t") return null;
    if (type == "int") return ffi.sint;
    if (type == "size_t") return ffi.pointer;
    if (type == "void") return ffi.void;
    if (type == "float") return ffi.float;
    if (type == "short") return null;
    if (type == "double") return ffi.double;
    if (type == "signed char") return null;
    if (type == "unsigned int") return ffi.uint;
    if (type == "unsigned char") return null;
    if (type == "unsigned short") return null;
    if (type == "long") return null;
    if (type == "unsigned long") return null;
    if (type == "uint8_t") return ffi.uint8;
    if (type == "uint16_t") return ffi.uint16;
    if (type == "uint32_t") return ffi.uint32;
    if (type == "uint64_t") return ffi.uint64;
    if (type == "int8_t") return ffi.int8;
    if (type == "int16_t") return ffi.int16;
    if (type == "int32_t") return ffi.int32;
    if (type == "int64_t") return ffi.int64;
    return xml_type_to_ffi(global_typemap[type]);
  }
  
  var obj = {};
  var library = ffi.open(lib_file);
  print("select fn decls");
  var fndecls = decls.filter(function(node) {
    return getAttr(node, "kind") == "function";
  });
  print("done.");
  i = 0;
  print("parse ", fndecls.length, " fn decls");
  while (i < fndecls.length) {
    var decl = fndecls[i];
    // print("? ", getAttr(decl, "name"));
    var ret_type;
    // print(getAttr(decl, "decl"), ", ", getAttr(decl, "type"), " # ", getAttr(decl, "decl").endsWith(".p."));
    if (getAttr(decl, "decl").endsWith(".p.")) ret_type = ffi.pointer; // why, ffi
    else ret_type = xml_type_to_ffi(getAttr(decl, "type"));
    if (ret_type) {
      var parms = decl.findByName("parm");
      var par_types = [];
      var k = 0;
      var good = true;
      while (k < parms.length) {
        var parm = parms[k];
        var typestr = getAttr(parm, "type");
        var skip = 0;
        if (parms.length == 1) { if (typestr == "void") { skip = 1; } }
        if (skip == 0) {
          var type = xml_type_to_ffi(typestr);
          if (type) { } else {
            good = false;
            // print("arg skip ", getAttr(decl, "name"));
          }
          par_types.push(type);
        }
        k = k + 1;
      }
      if (good) {
        var name = getAttr(decl, "name");
        var sym = library.sym(name, ret_type, par_types);
        if (sym) {
          // print("+ ", name);
          obj[name] = sym;
        } // else print("sym skip ", getAttr(decl, "name"));
      } // else print("bad skip ", getAttr(decl, "name"));
    } // else print("ret skip ", getAttr(decl, "name"));
    i = i + 1;
  }
  print("done.");
  print("filter constants");
  var constants = xmldata.findByName("constant");
  print("done.");
  i = 0;
  print("parse ", constants.length, " constants");
  while (i < constants.length) {
    var constant = constants[i];
    var name = getAttr(constant, "name");
    var value = getAttr(constant, "value");
    value = int.parse(value);
    // print("+ '", name, "'");
    obj[name] = value;
    i = i + 1;
  }
  print("done.");
  // swig doesn't generate this properly for sdl
  /*
  print("filter enum items");
  var enumitems = xmldata.findByName("enumitem");
  print("done.");
  print("parse ", enumitems.length, " flags");
  i = 0;
  while (i < enumitems.length) {
    var enumitem = enumitems[i];
    var name = getAttr(enumitem, "name");
    var value = getAttr(enumitem, "value");
    value = int.parse(value);
    obj[name] = value;
    i = i + 1;
  }
  print("done.");
  */
  return obj;
}

var gl = loadLibrary("gl_wrap.xml", "libGL.so");
var sdl = loadLibrary("SDL_wrap.xml", "libSDL.so");

sdl["SDL_QUIT"] = 12;

var glu = loadLibrary("glu_wrap.xml", "libGLU.so");

function drawGL() {
  gl.glViewport(0, 0, 800, 600);
  gl.glMatrixMode(gl.GL_PROJECTION);
  gl.glLoadIdentity();
  glu.gluPerspective(45, 800.0/600, 0.1, 100);
  gl.glMatrixMode(gl.GL_MODELVIEW);
  gl.glLoadIdentity();
  
  gl.glShadeModel(gl.GL_SMOOTH);
  gl.glClearDepth(1);
  gl.glDepthFunc(gl.GL_LEQUAL);
  gl.glEnable(gl.GL_DEPTH_TEST);
  gl.glClearColor(0.2, 0.2, 0.2, 0);
  gl.glHint(gl.GL_PERSPECTIVE_CORRECTION_HINT, gl.GL_NICEST);
  
  // TODO '|'
  gl.glClear(gl.GL_COLOR_BUFFER_BIT + gl.GL_DEPTH_BUFFER_BIT);
  gl.glLoadIdentity();
  gl.glTranslatef(-1.5, 0.0, -6.0);
  gl.glColor3f(1, 1, 1);
  gl.glBegin(gl.GL_TRIANGLES);
  gl.glVertex3f( 0.0,  1.0, 0.0);
  gl.glVertex3f(-1.0, -1.0, 0.0);
  gl.glVertex3f( 1.0, -1.0, 0.0);
  gl.glEnd();
  
  gl.glTranslatef(3.0, 0.0, 0.0);
  
  gl.glBegin(gl.GL_QUADS);
  gl.glVertex3f(-1.0, 1.0, 0.0);
  gl.glVertex3f( 1.0, 1.0, 0.0);
  gl.glVertex3f( 1.0,-1.0, 0.0);
  gl.glVertex3f(-1.0,-1.0, 0.0);
  gl.glEnd();
}

sdl.SDL_Init(sdl.SDL_INIT_EVERYTHING);
// TODO '|'
sdl.SDL_SetVideoMode(800, 600, 32, sdl.SDL_OPENGL + sdl.SDL_RESIZABLE);
var event = malloc(64);
var running = true;
return 0;
while (running) {
  while (sdl.SDL_PollEvent(event)) {
    if (event.dereference(ffi.uint8) == sdl.SDL_QUIT) running = false;
  }
  drawGL();
  sdl.SDL_GL_SwapBuffers();
}
sdl.SDL_Quit();
return 0;

var obj = {a: 5, b: null, bar: method() { print(this.a - this.b); } };
obj.b = /* test */ 7;
var obj2 = new obj { b: 9 };
var objx = new 5 { bar: 7 }; print("objx = "+(objx + objx.bar));
var arr = [2, 3, 4];
arr[1] = 7;
var vv = arr.push(5).pop(); print("vv = " + vv);
print("" + arr[0] + ", " + arr[1] + ", " + arr[2] + " (" + arr.length + ")");
obj["foo"] = method() { print(this.a + this.b); };
obj.foo();
obj.bar();
obj2.foo();
obj2.bar();
var Class = { a: 0 };
var SubClass = new Class { b: 0, test: method() { print("a + b = " + (this.a + this.b)); } };
var obj = new SubClass;
obj.a = 5;
obj.b = 8;
obj.test();
print("debug: "+obj.a+", "+obj.b);
print("2 != 2 = "+(2 != 2));
print("2 !< 2 = "+(2 !< 2));
print("2 !> 2 = "+(2 !> 2));
print("2 !<= 2 = "+(2 !<= 2));
print("2 !>= 2 = "+(2 !>= 2));
var i = 0; while (i < 10) { print("i = "+i); i = i + 1; }
