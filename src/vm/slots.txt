/* first read slots, then write slots */
#ifndef CHKSLOT_REF
#define CHKSLOT_REF(I)
#define DEFINED_CHKSLOT_REF
#endif

#define READ_SLOT(X) \
  if ((X).kind == ARG_SLOT) { CHKSLOT_READ((X).slot); } \
  else if ((X).kind == ARG_REFSLOT) { CHKSLOT_REF((X).refslot); }

#define WRITE_SLOT(X) \
  if ((X).kind == ARG_SLOT) { CHKSLOT_WRITE((X).slot); } \
  else if ((X).kind == ARG_REFSLOT) { CHKSLOT_REF((X).refslot); }

CASE(INSTR_ALLOC_OBJECT, AllocObjectInstr)
  CHKSLOT_READ(instr->base.context_slot); CHKSLOT_READ(instr->parent_slot); CHKSLOT_WRITE(instr->target_slot);
CASE(INSTR_ALLOC_INT_OBJECT, AllocIntObjectInstr)
  CHKSLOT_READ(instr->base.context_slot);
  WRITE_SLOT(instr->target);
CASE(INSTR_ALLOC_BOOL_OBJECT, AllocBoolObjectInstr)
  CHKSLOT_READ(instr->base.context_slot);
  WRITE_SLOT(instr->target);
CASE(INSTR_ALLOC_FLOAT_OBJECT, AllocFloatObjectInstr)
  CHKSLOT_READ(instr->base.context_slot);
  WRITE_SLOT(instr->target);
CASE(INSTR_ALLOC_ARRAY_OBJECT, AllocArrayObjectInstr)
  CHKSLOT_READ(instr->base.context_slot);
  WRITE_SLOT(instr->target);
CASE(INSTR_ALLOC_STRING_OBJECT, AllocStringObjectInstr)
  CHKSLOT_READ(instr->base.context_slot);
  WRITE_SLOT(instr->target);
CASE(INSTR_ALLOC_CLOSURE_OBJECT, AllocClosureObjectInstr)
  CHKSLOT_READ(instr->base.context_slot);
  WRITE_SLOT(instr->target);
CASE(INSTR_FREE_OBJECT, FreeObjectInstr)
  CHKSLOT_READ(instr->base.context_slot); CHKSLOT_READ(instr->obj_slot);
CASE(INSTR_CLOSE_OBJECT, CloseObjectInstr)
  CHKSLOT_READ(instr->base.context_slot); CHKSLOT_READ(instr->slot);
CASE(INSTR_FREEZE_OBJECT, FreezeObjectInstr)
  CHKSLOT_READ(instr->base.context_slot); CHKSLOT_READ(instr->slot);
CASE(INSTR_ACCESS, AccessInstr)
  CHKSLOT_READ(instr->base.context_slot);
  READ_SLOT(instr->obj);
  READ_SLOT(instr->key);
  WRITE_SLOT(instr->target);
CASE(INSTR_ASSIGN, AssignInstr)
  CHKSLOT_READ(instr->base.context_slot);
  READ_SLOT(instr->obj);
  READ_SLOT(instr->key);
  READ_SLOT(instr->value);
  CHKSLOT_WRITE(instr->target_slot);
CASE(INSTR_KEY_IN_OBJ, KeyInObjInstr)
  CHKSLOT_READ(instr->base.context_slot);
  READ_SLOT(instr->key);
  READ_SLOT(instr->obj);
  WRITE_SLOT(instr->target);
CASE(INSTR_IDENTICAL, IdenticalInstr)
  CHKSLOT_READ(instr->base.context_slot);
  READ_SLOT(instr->obj1);
  READ_SLOT(instr->obj2);
  WRITE_SLOT(instr->target);
CASE(INSTR_INSTANCEOF, InstanceofInstr)
  CHKSLOT_READ(instr->base.context_slot);
  READ_SLOT(instr->obj);
  READ_SLOT(instr->proto);
  WRITE_SLOT(instr->target);
CASE(INSTR_SET_CONSTRAINT, SetConstraintInstr)
  CHKSLOT_READ(instr->base.context_slot);
  READ_SLOT(instr->obj);
  READ_SLOT(instr->key);
  READ_SLOT(instr->constraint);
CASE(INSTR_TEST, TestInstr)
  CHKSLOT_READ(instr->base.context_slot);
  READ_SLOT(instr->value);
  WRITE_SLOT(instr->target);
CASE(INSTR_CALL, CallInstr)
  CHKSLOT_READ(instr->base.context_slot);
  READ_SLOT(instr->info.fn);
  READ_SLOT(instr->info.this_arg);
  for (int k = 0; k < instr->info.args_len; ++k) {
    Arg *arg = &((Arg*)(&instr->info+1))[k];
    READ_SLOT(*arg);
  }
  WRITE_SLOT(instr->info.target);
CASE(INSTR_CALL_FUNCTION_DIRECT, CallFunctionDirectInstr)
  CHKSLOT_READ(instr->base.context_slot);
  READ_SLOT(instr->info.fn);
  READ_SLOT(instr->info.this_arg);
  for (int k = 0; k < instr->info.args_len; ++k) {
    Arg *arg = &((Arg*)(&instr->info+1))[k];
    READ_SLOT(*arg);
  }
  WRITE_SLOT(instr->info.target);
CASE(INSTR_RETURN, ReturnInstr)
  CHKSLOT_READ(instr->base.context_slot);
  READ_SLOT(instr->ret);
CASE(INSTR_BR, BranchInstr)
  CHKSLOT_READ(instr->base.context_slot);
CASE(INSTR_TESTBR, TestBranchInstr)
  CHKSLOT_READ(instr->base.context_slot);
  READ_SLOT(instr->test);
CASE(INSTR_PHI, PhiInstr)
  CHKSLOT_READ(instr->base.context_slot);
  READ_SLOT(instr->arg1);
  READ_SLOT(instr->arg2);
  WRITE_SLOT(instr->target);

CASE(INSTR_ACCESS_STRING_KEY, AccessStringKeyInstr)
  CHKSLOT_READ(instr->base.context_slot);
  CHKSLOT_WRITE(instr->key_slot); /* scratch space for calls */
  READ_SLOT(instr->obj);
  WRITE_SLOT(instr->target);
CASE(INSTR_ASSIGN_STRING_KEY, AssignStringKeyInstr)
  CHKSLOT_READ(instr->base.context_slot);
  CHKSLOT_WRITE(instr->target_slot);
  READ_SLOT(instr->obj);
  READ_SLOT(instr->value);
CASE(INSTR_STRING_KEY_IN_OBJ, StringKeyInObjInstr)
  CHKSLOT_READ(instr->base.context_slot);
  READ_SLOT(instr->obj);
  WRITE_SLOT(instr->target);
CASE(INSTR_SET_CONSTRAINT_STRING_KEY, SetConstraintStringKeyInstr)
  CHKSLOT_READ(instr->base.context_slot);
  READ_SLOT(instr->obj);
  READ_SLOT(instr->constraint);
CASE(INSTR_DEFINE_REFSLOT, DefineRefslotInstr)
  CHKSLOT_READ(instr->base.context_slot);
  CHKSLOT_READ(instr->obj_slot);
  CHKSLOT_REF(instr->target_refslot);
CASE(INSTR_MOVE, MoveInstr)
  CHKSLOT_READ(instr->base.context_slot);
  READ_SLOT(instr->source);
  WRITE_SLOT(instr->target);
CASE(INSTR_ALLOC_STATIC_OBJECT, AllocStaticObjectInstr)
  CHKSLOT_READ(instr->base.context_slot);
  for (int k = 0; k < instr->tbl.entries_stored; ++k) {
    CHKSLOT_READ(ASOI_INFO(instr)[k].slot);
    CHKSLOT_REF(ASOI_INFO(instr)[k].refslot);
  }
  CHKSLOT_READ(instr->parent_slot);
  CHKSLOT_WRITE(instr->target_slot);

#ifdef DEFINED_CHKSLOT_REF
#undef DEFINED_CHKSLOT_REF
#undef CHKSLOT_REF
#endif
