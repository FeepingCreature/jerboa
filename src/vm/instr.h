#ifndef VM_INSTR_H
#define VM_INSTR_H

#include <stdbool.h>
#include <stdlib.h>

typedef enum {
  INSTR_INVALID = -1,
  INSTR_GET_ROOT = 0,
  INSTR_ALLOC_OBJECT,
  INSTR_ALLOC_INT_OBJECT,
  INSTR_ALLOC_BOOL_OBJECT,
  INSTR_ALLOC_FLOAT_OBJECT,
  INSTR_ALLOC_ARRAY_OBJECT,
  INSTR_ALLOC_STRING_OBJECT,
  INSTR_ALLOC_CLOSURE_OBJECT,
  INSTR_CLOSE_OBJECT,
  INSTR_FREEZE_OBJECT,
  INSTR_ACCESS,
  INSTR_ASSIGN,
  INSTR_KEY_IN_OBJ,
  INSTR_INSTANCEOF,
  INSTR_SET_CONSTRAINT,
  INSTR_CALL,
  INSTR_RETURN,
  INSTR_BR,
  INSTR_TESTBR,
  INSTR_PHI,
  // everything below this point is only generated by optimizer passes
  INSTR_ACCESS_STRING_KEY,
  INSTR_ASSIGN_STRING_KEY,
  INSTR_SET_CONSTRAINT_STRING_KEY,
  INSTR_SET_SLOT,
  INSTR_DEFINE_REFSLOT,
  INSTR_READ_REFSLOT,
  INSTR_WRITE_REFSLOT,
  // object is allocated, some fields are defined, object is closed, and refslots are created for its fields
  // this is a very common pattern due to scopes
  INSTR_ALLOC_STATIC_OBJECT,
  
  INSTR_LAST
} InstrType;

typedef enum {
  // just write the key to the top object, already-present or not
  // ie. hashtable-type access
  ASSIGN_PLAIN,
  // replace an existing key (somewhere in the chain), error if absent
  // ie. scope-type access
  ASSIGN_EXISTING,
  // shadow an existing key (write to top object), but error if absent anywhere
  // ie. object-type access
  ASSIGN_SHADOWING
} AssignType;

typedef struct {
  char *file;
  char *text_from; int row_from, col_from;
  char *text_to;   int row_to  , col_to  ;
  int last_cycle_seen;
} FileRange;

typedef struct {
  InstrType type;
  int context_slot;
  FileRange *belongs_to;
} Instr;

int instr_size(Instr*);

// Note: the IR is *lexically ordered*.
// That means, any use of a slot must come after its initialization *in iteration order*.
typedef struct {
  int offset, size;
} InstrBlock;

typedef struct {
  InstrBlock* blocks_ptr; int blocks_len;
  // first instruction of first block to last instruction of last block
  // (linear because cache)
  Instr *instrs_ptr, *instrs_ptr_end;
} FunctionBody;

#define BLOCK_START(FN, IDX) ((Instr*) ((char*) (FN)->body.instrs_ptr + (FN)->body.blocks_ptr[IDX].offset))
#define BLOCK_END(FN, IDX) ((Instr*) ((char*) (FN)->body.instrs_ptr + (FN)->body.blocks_ptr[IDX].offset + (FN)->body.blocks_ptr[IDX].size))

typedef struct {
  int arity; // first n slots are reserved for parameters
  int slots, refslots;
  char *name;
  bool is_method, variadic_tail;
  FunctionBody body;
  bool non_ssa, optimized;
} UserFunction;


typedef struct {
  Instr base;
  int slot;
} GetRootInstr;

struct _Object;
typedef struct _Object Object;

typedef struct {
  Instr base;
  int target_slot, parent_slot;
} AllocObjectInstr;

typedef struct {
  Instr base;
  int target_slot;
  int value;
} AllocIntObjectInstr;

typedef struct {
  Instr base;
  int target_slot;
  bool value;
} AllocBoolObjectInstr;

typedef struct {
  Instr base;
  int target_slot;
  float value;
} AllocFloatObjectInstr;

typedef struct {
  Instr base;
  int target_slot;
} AllocArrayObjectInstr;

typedef struct {
  Instr base;
  int target_slot;
  char *value;
} AllocStringObjectInstr;

typedef struct {
  Instr base;
  int target_slot;
  UserFunction *fn;
} AllocClosureObjectInstr;

typedef struct {
  Instr base;
  int slot;
} CloseObjectInstr;

typedef struct {
  Instr base;
  int slot;
} FreezeObjectInstr;

typedef struct {
  Instr base;
  int obj_slot, key_slot;
  int target_slot;
} AccessInstr;

typedef struct {
  Instr base;
  int obj_slot, value_slot, key_slot, target_slot /* scratch space for calls */;
  AssignType type;
} AssignInstr;

typedef struct {
  Instr base;
  int obj_slot, key_slot, target_slot;
} KeyInObjInstr;

typedef struct {
  Instr base;
  int obj_slot, proto_slot, target_slot;
} InstanceofInstr;

typedef struct {
  Instr base;
  int obj_slot, key_slot, constraint_slot;
} SetConstraintInstr;

typedef struct {
  Instr base;
  int function_slot, this_slot;
  int args_length; // attached to callinstr as a tail
  int target_slot;
} CallInstr;

typedef struct {
  Instr base;
  int ret_slot;
} ReturnInstr;

typedef struct {
  Instr base;
  int target_slot;
} SaveResultInstr;

typedef struct {
  Instr base;
  int blk;
} BranchInstr;

typedef struct {
  Instr base;
  int test_slot;
  int true_blk, false_blk;
} TestBranchInstr;

typedef struct {
  Instr base;
  int block1, slot1;
  int block2, slot2;
  int target_slot;
} PhiInstr;

typedef struct {
  Instr base;
  int obj_slot;
  char *key_ptr; int key_len;
  size_t key_hash;
  int target_slot;
} AccessStringKeyInstr;

typedef struct {
  Instr base;
  int obj_slot, value_slot; char *key;
  AssignType type;
} AssignStringKeyInstr;

typedef struct {
  Instr base;
  int obj_slot, constraint_slot;
  char *key_ptr; int key_len;
} SetConstraintStringKeyInstr;

typedef struct {
  Instr base;
  int target_slot;
  Object *value;
  char *opt_info;
} SetSlotInstr;

typedef struct {
  Instr base;
  int target_refslot;
  int obj_slot;
  char *key_ptr; int key_len;
  size_t key_hash;
} DefineRefslotInstr;

typedef struct {
  Instr base;
  int source_refslot, target_slot;
  char *opt_info;
} ReadRefslotInstr;

typedef struct {
  Instr base;
  int source_slot, target_refslot;
  char *opt_info;
} WriteRefslotInstr;

typedef struct {
  char *name_ptr;
  int name_len;
  size_t name_hash;
  
  Object *constraint;
  
  int slot;
  int refslot;
} StaticFieldInfo;

// object is allocated, some fields are defined, object is closed, and refslots are created for its fields
typedef struct {
  Instr base;
  int target_slot, parent_slot;
  
  int info_len;
  StaticFieldInfo *info_ptr;
} AllocStaticObjectInstr;

#endif
